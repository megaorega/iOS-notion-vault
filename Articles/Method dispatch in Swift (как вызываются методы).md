# Quick hint
| | Static/Direct | Table | Message |
| ---: | --- | - | --- |
| __NSObject__ | `@nonobjc` или `final` | Initial declaration | Extension declaration `dynamic` |
| __Class__ | Extension declaration или `final` | Initial declaration | `dynamic` |
| __Protocol__ | Extension declaration | Initial declaration | Obj-C declarations `@objc` declaration modifier |
| __Value type__ | All methods, always | n/a | n/a |
> [! Оптимизация кода]
> Если включить `whole module optimization` для компилятора, то он будет оптимизировать код и использовать самую _быструю диспетчеризацию_ из возможных. 
> Если метод объявить просто как `func`, то компилятор по умолчанию сделает его `final` и будет использована _статическая диспетчеризация_.
> Нет смысла руками помечать все методы как `final` или объявлять их в extension.



# Abstract
__Method dispatch__ (диспетчеризация) это то, как программа выбирает, какие инструкции ей выполнить при вызове метода.



## Виды диспетчеризации (основные):

### Static / Direct (статическая / прямая)
>Разруливается на стадии компиляции. Запрещает наследование и преопределение методов (в Свифте). Самая быстрая, но самая ограниченная.

### Table (табличная)
>Разруливается в рантайме. Для этого рантайм имеет таблицу со ссылками на методы (они называются virtual table/witness table и подобным образом). Таблица создается на этапе компиляции. Каждый наследник класса имеет свою измененную копию этой таблицы:![[table_dispatch_in_swift_scheme.png]]
>Ссылка на метод родительского класса остается неизменной. Ссылка на переопределенный метод заменяется на новую. Новые методы у дочернего класса помещаются в конец таблицы. 
>
>Так как для доступа к методу нужно выполнять дополнительные действия по поиску – вызов таких методов получается медленнее, чем при статической диспетчеризации.

### Message (на сообщениях)
> Включается с помощью ключевого слова `dynamic`:
```swift
class ParentClass {
dynamic func method1() {} 
dynamic func method2() {} 
}

class ChildClass: ParentClass {
override func method2() {}
func method3() {}
}
```
> Разруливается в рантайме. Использует swizzling для подмены реализации методов на другую. С помощью isa-swizzling (от "is a") можно поменять тип объекта.
>Самая динамическая диспетчеризация. Самая медленная (но есть кэширование: если один раз рантайм прошелся по всей иерархии, то во второй раз это будет сделано со скоростью табличной). 



## В каких языках какие виды есть:
- __В Swift есть все виды__ (static/direct + table + message)
- В Java используется табличная и статическая через final
- В С++ статическая и табличная через virtual
- В ObjC на сообщениях (но так как поддерживается чистый Си, то можно использовать и статическую)



## Как выбирается вид диспетчеризации:

### По месту объявления метода и типу объекта
| | Initial declaration | Extension |
|-----:|:-----:|:-----:|
| Value type | Static | Static |
| Protocol | Table | Static |
| Class | Table | Static |
| NSObject subclass | Table | Message |

Исходя из этого: методы, которые объявлены в extension расширять нельзя, компилятор выдаст ошибку.
![[swift_dispatch_code_example.png]]

###  По модификаторам:
#### `final`
`final` запрещает наследование и переопределение. Если его объявить явно, то функцию нельзя будет переопределить. Если неявно, то если функция переопределена в подклассе, будет включена табличная диспетчеризация. `final` подставляется компилятором по умолчанию для включения статической диспетчеризации, если включен флаг компилятора `whole-module-optimization`
`final` скрывает метод от ObjC рантайма.
```swift
class Foo {
	func someFunc() {} // тут неявно объявлен final и если подклассы не переопределят этот метод – диспетчеризация будет статической. Если в каком-то дочернем классе будет override этого метода, то для всей иерархии включится табличная диспетчеризация
	final func someFinalFunc() {} // тут объявление явно включает статическую диспетчеризацию и этот метод нельзя будет переопределить
}

class Bar: Foo {
	override func someFunc() {} // это переопределение включит табличную диспетчеризацию вместо статической для этого метода
	override func someFinalFunc() {} // при компиляции будет ошибка, потому что метод явно объявлен как final в суперклассе и его нельзя переопределить
}
```

#### `dynamic`
`dynamic`  принудительно включает диспетчеризацию на сообщениях. Раньше открывал видимость ObjC рантайму (когда и когда перестал? #need_research), теперь нет.

#### `@objc` и `@nonobjc`
- `@objc` открывает метод ObjC рантайму, __но никак не меняет диспетчеризацию__.
- `@nonobjc` Используется по умолчанию. Скрывает метод от ObjC рантайма и __выключает__ диспетчеризацию на сообщениях.

#### `@inline`
Подсказка кодогенератору, которая включает static / direct диспетчеризацию



# Learning materials
### Articles & Links
- [Pallavi Dipke about method dispatch at Medium'](https://medium.com/@pallavidipke07/method-dispatch-in-swift-b113a40a713a)
- [Venkatesh Yadav.P about method dispatch at Medium](https://medium.com/@venki0119/method-dispatch-in-swift-effects-of-it-on-performance-b5f120e497d3)
### Videos:
- [Mad Brains. Method dispatch in Swift (43 min)](https://www.youtube.com/watch?v=KoCjIv0moEE)