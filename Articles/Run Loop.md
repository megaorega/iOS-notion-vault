# Abstract

### Зачем это нужно?
Цикл, который координирует получение и обработку входящих событий в конкретном потоке. 
Цель – загружать поток, когда есть работа и усыплять поток, когда работы нет, чтобы не расходовать лишние ресурсы.

### Потоки
У каждого потока есть ассоциированный с ним ран луп. Ран луп для главного потока приложение запускает и поддерживает автоматически. Для других потоков ран луп конфигурирует и запускает разработчик.

Нужен, чтобы приложение отвечало на ввод пользователя. Ран луп создается __после__ запуска лонч скрина, поэтому взаимодействовать с лонч скрином нельзя.

### События
Существует несколько источников событий для ран лупа:
- Устройства ввода (мышь, клавиатура, тачскрин)
- Порты (можно прослушивать порты с помощью `NSConnection`, но только на макОС)
- Кастомные источники (чтобы быстро передавать информацию из одного потока в другой)
- `performSelector: onThread:`  работает через ран луп
- Таймеры (таймер без ран лупа работать не будет)
- DisplayLink (`CADisplayLink`)
- 

### 5 режимов работы Ран Лупа
Есть 5 режимов работы Run Loop:
- `Default`
  Тут обрабатываются основные события
- `Connection`
  Используется для считывания информации с портов 
- `Modal`
  Режим для работы с модальными окнами в макОС
- `Event tracking`
  События с периферийных устройств, нажатия клавиш, тачскрин, скроллинг и прочее.
- `Common modes`
  Объединяет режимы: Default, Modal и Event tracking. Для мобильной разработки режим Modal не используется, поэтому остается только Default и Event Tracking.

Когда пользователь взаимодействует с UI, ран луп главного потока переходит в режим `Event tracking`.
Распространеная проблема: если создать таймер с помощью метода `Timer.scheduledTimer()`, то он добавится в ран луп главного потока для дефолтного режима. При скроллинге ран луп переключает режим и таймер не обрабатывается. Таким образом при скроллинге таймер не сработает. Чтобы пофиксить это, нужно добавлять таймер вот так:
```swift 
let timer = Timer() // создаем таймер через конструктор

// добавляем таймер в Ран Луп вручную и указываем режим common, чтобы таймер обрабатывался и в deafult и в режиме event tracking
RunLoop.main.add(timer, forMode: .common)
```

## Проблемы
Нельзя гарантировать, что таймер сработает в нужное нам время с точностью до миллисекунд. Ран луп обрабатывает события по порядку. Если событие срабатывания таймера добавилось в ран луп, оно обработается, когда ран луп дойдет до нужного шага. События таймеров обрабатываются в начале цикла, поэтому должно очень повезти, чтобы сразу после добавления события таймера начался шаг обработки таймеров, а не другой шаг.

## Use cases
#tbd 

# Learning materials
##### Articles
- 
##### Videos:
- [Mad Brains. Сложные вопросы по iOS: ](https://www.youtube.com/watch?v=pWXgH-GbRSU)
	- Toll-free bridging
	- Run Loop
	- Autorelease pool
	- Deadlock/Livelock
	- Lock Mutex Semaphore
	- Bitcode
	- dSYM
	- Сравнение NSOperationQueue и
	- GCD
